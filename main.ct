def infinite_recursion(_):
  infinite_recursion{} 

def omega(_):
  (x -> x(x))(x -> x(x)) 

def infinitely_recursive_object(_):
  {this.x: this.x}.x 

def laziness_example_1(_):
  // print 1, then 2
  (_ -> 
    let force _ = console.write(1)
    in console.write(2)
  )(infinite_recursion{})

def laziness_example_2(_):
  // print b
  let _ = console.write("a")
  in console.write("b")

def laziness_example_3(_):
  // print 1, then 2
  let force _ = console.write(1)
  in console.write(2)

def laziness_example_4(_):
  // demonstrating how laziness causes problems
  // this function echoes twice, 
  // instead of two prompts and then printing in reverse
  let x = console.read{}
  in let y = console.read{}
  in let force _ = console.write(y)
  in console.write(x)

def laziness_example_5(_):
  // here's how to correctly
  // prompt twice and then print in reverse:
  let force x = console.read{}
  in let force y = console.read{}
  in let force _ = console.write(y)
  in console.write(x)

def object_example_1(_):
  // a bunch of fun object trickery!
  let list = {
    e: case -> case.Empty,
    p: first-> rest-> case-> case.Has(first)(rest)
  }
  in let l = list.p(-0.5)(list.p(-0.6)(list.p(-0.2)(list.e)))
  // print out all the elements
  in l{
    Empty: 0,
    this.Has: first-> rest-> 
      let force _ = console.write(first)
      in rest(this) // apply this same pattern match to the tail!
  }

def object_example_2(_):
  let list = {
    e: case -> case.Empty,
    p: first-> rest-> case-> case.Has(first)(rest)
  }
  in let stream_of_ones = {this.val: list.p("hi!")(this.val)}.val
  in stream_of_ones{
    Has: first-> t-> t{
      Has: second-> _->
        let force _ = console.write(first)
        in console.write(second)
    }
  }

def object_example_3(_):
  let dog = {bark: "woof!"}
  in let cooper = dog <- name: "Cooper"
  in console.write(cooper.name + " says: " + cooper.bark)

import stdlib

def object_example_4(_):
  let List = stdlib.List
  in let Iter = stdlib.Iter
  in let my_list =
    List.Has(7)(
      List.Has(4)(
        List.Has(5)(List.Empty)
      )
    )
  in let fourth = it-> it.next.next.next.val
  // print "null"
  in let force _ = fourth(Iter(my_list)){
    Some: x-> console.write(x), // we could exclude this branch
    None: console.write("empty")
  }
  // print 5
  in fourth(Iter(List.Has(2)(my_list))){
    Some: x-> console.write(x),
    None: console.write("empty") // we could exclude this branch
  }

def backpassing_example(_):
  // prints 7
  let x <- callback->callback(7)
  in console.write(x)

def main(_):
  let force _ = laziness_example_1{} // print 1 then 2
  in let force _ = laziness_example_2{} // print "b"
  in let force _ = laziness_example_3{} // print 1 then 2
  // I commented these out because entering input is annoying:
  // in let force _ = laziness_example_4{} 
  // in let force _ = laziness_example_5{}
  in let force _ = object_example_1{} // print -0.5 then -0.6 then -0.2
  in let force _ = object_example_2{} // print "hi!" twice
  in let force _ = object_example_3{} // print "Cooper says: woof!"
  in let force _ = object_example_4{} // print "empty" then 5
  in let force _ = backpassing_example{} // print 7
  in console.write("All examples finished!")


